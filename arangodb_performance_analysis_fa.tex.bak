\documentclass[12pt, onecolumn, a4paper]{article}


\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{url}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows.meta,calc}
\usepackage[margin=2.5cm]{geometry} 


\usepackage{xepersian}
\usepackage{setspace}
\setstretch{1.3}


\settextfont[Scale=1.1]{Vazirmatn}
\setlatintextfont[Scale=1.0]{Times New Roman}


\lstset{
    basicstyle=\ttfamily\small\latin, 
    breaklines=true,
    frame=single,
    language=SQL,
    showstringspaces=false,
    direction=LTR,
    captionpos=b
}

\begin{document}
\sloppy

\title{تحلیل جامع عملکرد \lr{ArangoDB}: مطالعه مقایسه‌ای پایگاه‌داده‌های \lr{NoSQL} چندمدلی}

\author{علی بخشا\\
\textit{دانشکده علوم داده} \\
\textit{دانشگاه خلیج فارس}\\
\lr{alibakhsha@mehr.pgu.ac.ir}}

\date{\today}

\maketitle

\begin{abstract}
گسترش کلان‌داده‌ها و نیازمندی‌های متنوع کاربردی، تکامل پایگاه‌داده‌های \lr{NoSQL}\ را به همراه داشته است، به طوری که پایگاه‌داده‌های چندمدلی \lr{(Multi-model)}\ به عنوان یک راهکار یکپارچه برای مدیریت انواع داده‌های ناهمگن ظهور کرده‌اند. \lr{ArangoDB}\ به عنوان یک پایگاه‌داده چندمدلی بومی که از مدل‌های داده‌ای سند \lr{(Document)}، گراف \lr{(Graph)}\ و کلید-مقدار \lr{(Key-Value)}\ پشتیبانی می‌کند، جایگزینی جذاب برای استقرار چندین پایگاه‌داده تخصصی ارائه می‌دهد. این مقاله به تحلیل جامع عملکرد \lr{ArangoDB} می‌پردازد و آن را با پایگاه‌داده‌های پیشرو \lr{NoSQL} از جمله \lr{MongoDB} (ذخیره‌ساز سند)، \lr{Neo4j} (پایگاه‌داده گراف)، \lr{Redis} (ذخیره‌ساز کلید-مقدار) و \lr{Apache Cassandra} (ذخیره‌ساز ستونی) مقایسه می‌کند. از طریق بنچمارک‌گیری سیستماتیک در بارهای کاری مختلف، ما عملکرد پرس‌وجو، توان عملیاتی، تاخیر، مقیاس‌پذیری و کارایی منابع را ارزیابی می‌کنیم. نتایج تجربی ما نشان می‌دهد که \lr{ArangoDB} در هر سه مدل داده‌ای عملکرد رقابتی دارد و در عین حال انعطاف‌پذیری برتری برای بارهای کاری ترکیبی که نیاز به پرس‌وجوهای چندمدلی دارند، ارائه می‌دهد. به طور خاص، \lr{ArangoDB} برای پیمایش‌های پیچیده گراف در گراف‌های با اندازه متوسط (تا \lr{۱۰} میلیون یال)، \lr{۱۵} تا \lr{۲۰} درصد تاخیر کمتری نسبت به پایگاه‌داده‌های تخصصی گراف نشان می‌دهد و \lr{۸۵} تا \lr{۹۵} درصد از توان عملیاتی \lr{MongoDB} را برای عملیات سند حفظ می‌کند. این مطالعه بینش‌هایی را در مورد موازنه بین رویکردهای تخصصی و چندمدلی ارائه می‌دهد و راهنمایی‌هایی برای انتخاب پایگاه‌داده بر اساس نیازمندی‌های کاربردی فراهم می‌کند.
\end{abstract}

\textbf{واژگان کلیدی:} \lr{ArangoDB}، پایگاه‌داده‌های \lr{NoSQL}، پایگاه‌داده‌های چندمدلی، بنچمارک عملکرد، پایگاه‌داده‌های گراف، ذخیره‌سازهای سند، مقایسه پایگاه‌داده.

\section{مقدمه}

چشم‌انداز سیستم‌های مدیریت پایگاه‌داده در دو دهه گذشته دستخوش تحولات قابل توجهی شده است. پایگاه‌داده‌های رابطه‌ای سنتی، اگرچه قدرتمند و بالغ هستند، در پاسخگویی به نیازهای مقیاس‌پذیری، انعطاف‌پذیری و عملکرد برنامه‌های مدرن داده‌محور با چالش‌هایی روبرو هستند \cite{harrison2015next}. ظهور پایگاه‌داده‌های \lr{NoSQL} با قربانی کردن ویژگی‌های سخت‌گیرانه \lr{ACID} و اسکیمای رابطه‌ای به نفع مقیاس‌پذیری افقی، مدل‌های داده‌ای منعطف و عملکرد بهینه برای موارد استفاده خاص، به این محدودیت‌ها پاسخ داد \cite{davoudian2018survey}.

\subsection{تکامل \lr{NoSQL}}

پایگاه‌داده‌های \lr{NoSQL} معمولاً به چهار دسته اصلی تقسیم می‌شوند: ذخیره‌سازهای سند (مانند \lr{MongoDB, CouchDB})، ذخیره‌سازهای کلید-مقدار (مانند \lr{Redis, DynamoDB})، ذخیره‌سازهای خانواده ستونی (مانند \lr{Cassandra, HBase}) و پایگاه‌داده‌های گراف (مانند \lr{Neo4j, JanusGraph}) \cite{han2011survey}. هر دسته در سناریوهای خاصی برتری دارد: ذخیره‌سازهای سند انعطاف‌پذیری را برای داده‌های نیمه‌ساختاریافته فراهم می‌کنند، ذخیره‌سازهای کلید-مقدار عملکرد خواندن/نوشتن فوق‌العاده‌ای برای پرس‌وجوهای ساده ارائه می‌دهند، ذخیره‌سازهای ستونی تحلیل‌های کارآمد روی مجموعه داده‌های بزرگ را ممکن می‌سازند و پایگاه‌داده‌های گراف پرس‌وجوهای مبتنی بر روابط را بهینه می‌کنند.

با این حال، برنامه‌های کاربردی مدرن به طور فزاینده‌ای به چندین مدل داده به طور همزمان نیاز دارند. برای مثال، یک پلتفرم رسانه اجتماعی ممکن است به ذخیره‌سازی سند برای پروفایل کاربران، ساختارهای گراف برای شبکه‌های اجتماعی و دسترسی کلید-مقدار برای مدیریت نشست‌ها (\lr{Session}) نیاز داشته باشد. به طور سنتی، این امر مستلزم استقرار و نگهداری چندین سیستم پایگاه‌داده است که پیچیدگی عملیاتی، چالش‌های همگام‌سازی داده‌ها و هزینه‌های زیرساخت را افزایش می‌دهد \cite{lu2019multi}.

\subsection{پارادایم پایگاه‌داده چندمدلی}

پایگاه‌داده‌های چندمدلی برای رفع این پراکندگی با پشتیبانی از چندین مدل داده در یک موتور پایگاه‌داده واحد ظهور کردند. \lr{ArangoDB}\ که در سال \lr{۲۰۱۱}\ معرفی شد، یک رویکرد چندمدلی بومی (\lr{Native})\ را نشان می‌دهد که از پایه برای مدیریت اسناد، گراف‌ها و جفت‌های کلید-مقدار با یک زبان پرس‌وجوی واحد طراحی شده است~\cite{arangodb2023documentation}. این در تضاد با پایگاه‌داده‌هایی است که پشتیبانی چندمدلی را به صورت گذشته‌نگر از طریق افزونه‌ها اضافه کرده‌اند.

مزایای نظری پایگاه‌داده‌های چندمدلی عبارتند از:
\begin{itemize}
    \item \textbf{کاهش پیچیدگی عملیاتی}: یک سیستم پایگاه‌داده واحد برای استقرار، نظارت و نگهداری.
    \item \textbf{سازگاری داده‌ها}: معناشناسی تراکنش یکپارچه در سراسر مدل‌های داده.
    \item \textbf{انعطاف‌پذیری پرس‌وجو}: توانایی ترکیب عملیات در مدل‌های مختلف.
    \item \textbf{کارایی هزینه}: کاهش سربار زیرساخت و مجوزها.
\end{itemize}

\subsection{انگیزه و اهداف تحقیق}

با وجود این مزایای نظری، سوالات اساسی در مورد پیامدهای عملکردی عملی رویکرد چندمدلی باقی مانده است. آیا تعمیم‌یافتگی ذاتی در پشتیبانی از چندین مدل، عملکرد را در مقایسه با پایگاه‌داده‌های تخصصی به خطر می‌اندازد؟ آیا یک زبان پرس‌وجوی واحد می‌تواند عملیات را در پارادایم‌های مختلف داده به طور کارآمد بیان کند؟ عملکرد با افزایش حجم داده‌ها چگونه مقیاس می‌شود؟

این مطالعه با هدف پاسخگویی به این سوالات از طریق بنچمارک‌گیری و تحلیل جامع انجام شده است. اهداف خاص تحقیق ما عبارتند از:

\begin{enumerate}
    \item \textbf{توصیف عملکرد}: اندازه‌گیری سیستماتیک عملکرد \lr{ArangoDB} در بارهای کاری سند، گراف و کلید-مقدار.
    \item \textbf{تحلیل مقایسه‌ای}: بنچمارک \lr{ArangoDB} در برابر پایگاه‌داده‌های تخصصی پیشرو در هر دسته.
    \item \textbf{ارزیابی مقیاس‌پذیری}: ارزیابی ویژگی‌های مقیاس‌پذیری افقی و عملکرد خوشه‌ای.
    \item \textbf{مزیت چندمدلی}: کمی‌سازی مزایای عملکرد برای پرس‌وجوهایی که چندین مدل داده را در بر می‌گیرند.
    \item \textbf{تحلیل موازنه}: شناسایی سناریوهایی که پایگاه‌داده‌های تخصصی مزایای خود را حفظ می‌کنند.
\end{enumerate}

\subsection{مشارکت‌ها}

این مقاله مشارکت‌های زیر را ارائه می‌دهد:
\begin{itemize}
    \item بنچمارک‌های جامع عملکرد که \lr{ArangoDB} را با \lr{MongoDB}، \lr{Neo4j}، \lr{Redis} و \lr{Cassandra} در بارهای کاری استاندارد مقایسه می‌کند.
    \item تحلیل عملکرد پرس‌وجو برای عملیات سند، پیمایش گراف و الگوهای دسترسی کلید-مقدار.
    \item ارزیابی قابلیت‌های پرس‌وجوی چندمدلی منحصر به فرد برای \lr{ArangoDB}.
    \item تحلیل مقیاس‌پذیری در پیکربندی‌های خوشه‌ای از تک‌گره تا استقرارهای توزیع‌شده.
    \item توصیه‌های عملی برای انتخاب پایگاه‌داده بر اساس ویژگی‌های بار کاری.
\end{itemize}

\subsection{سازماندهی مقاله}

ادامه این مقاله به شرح زیر سازماندهی شده است: بخش دوم کارهای مرتبط در ارزیابی عملکرد \lr{NoSQL} و پایگاه‌داده‌های چندمدلی را مرور می‌کند. بخش سوم معماری و ویژگی‌های کلیدی \lr{ArangoDB} را توصیف می‌کند. بخش چهارم روش‌شناسی تجربی و طراحی بنچمارک ما را شرح می‌دهد. بخش پنجم نتایج عملکرد را در انواع مختلف بار کاری ارائه می‌دهد. بخش ششم موارد استفاده و پیامدهای عملی را مورد بحث قرار می‌دهد. بخش هفتم یافته‌ها را تحلیل و موازنه‌ها را شناسایی می‌کند. بخش هشتم با توصیه‌ها و جهت‌گیری‌های تحقیقاتی آینده نتیجه‌گیری می‌کند.

\section{مرور ادبیات و کارهای مرتبط}

\subsection{طبقه‌بندی پایگاه‌داده‌های \lr{NoSQL}}

اصطلاح «\lr{NoSQL}» شامل معماری‌های متنوع پایگاه‌داده است که با جدایی از مدل‌های رابطه‌ای سنتی متحد شده‌اند. طبقه‌بندی تاثیرگذار \lr{Cattell} \cite{cattell2011scalable} دسته‌های بنیادی را بر اساس مدل‌های داده و تضمین‌های سازگاری ایجاد کرد. کار بعدی توسط \lr{Han} و همکاران \cite{han2011survey} این طبقه‌بندی را اصلاح کرد و بر پیامدهای قضیه \lr{CAP} برای انواع مختلف \lr{NoSQL} تاکید نمود.

بررسی‌های اخیر \cite{davoudian2018survey, grolinger2013data} بلوغ اکوسیستم‌های \lr{NoSQL} و پذیرش فزاینده آن‌ها در محیط‌های تولیدی را برجسته می‌کنند. ذخیره‌سازهای سند مانند \lr{MongoDB} به دلیل اسکیمای منعطف خود برای مدیریت محتوا و بک‌اند موبایل محبوبیت پیدا کرده‌اند \cite{boicea2012mongodb}. پایگاه‌داده‌های گراف مانند \lr{Neo4j} برای شبکه‌های اجتماعی، موتورهای توصیه و کشف تقلب که در آن‌ها پرس‌وجوهای مبتنی بر روابط غالب هستند، استاندارد شده‌اند \cite{robinson2015graph}.

\subsection{بنچمارک عملکرد \lr{NoSQL}}

ارزیابی عملکرد پایگاه‌داده‌های \lr{NoSQL} توجه قابل توجهی را به خود جلب کرده است. بنچمارک سرویس‌دهی ابری \lr{Yahoo! (YCSB)} \cite{cooper2010benchmarking} الگوهای بار کاری استانداردی را برای مقایسه ذخیره‌سازهای کلید-مقدار و سند ایجاد کرد. افزونه‌هایی مانند \lr{YCSB++} \cite{patil2017ycsb++} پشتیبانی از پایگاه‌داده‌های گراف و الگوهای پرس‌وجوی غنی‌تر را اضافه کردند.

مطالعات مقایسه‌ای موازنه‌های عملکرد را در دسته‌های \lr{NoSQL} بررسی کرده‌اند. \lr{Li} و \lr{Manoharan} \cite{li2013performance} پایگاه‌داده‌های \lr{MongoDB}، \lr{Cassandra} و \lr{HBase} را مقایسه کردند و تغییرات عملکرد قابل توجهی را بر اساس نسبت‌های خواندن/نوشتن و اندازه داده‌ها یافتند. \lr{Jouili} و \lr{Vansteenberghe} \cite{jouili2013empirical} پایگاه‌داده‌های گراف را بنچمارک کردند و نشان دادند که پیچیدگی اسکیما و عمق پیمایش به طور قابل توجهی بر تاخیر پرس‌وجو تاثیر می‌گذارد.

تحقیقات در مورد عملکرد ذخیره‌ساز سند به ویژه بر \lr{MongoDB} به دلیل محبوبیت آن متمرکز بوده است. مطالعات اعتبارسنجی \cite{validation2019} کارایی \lr{MongoDB} را برای بازیابی اسناد نشان می‌دهند اما کاهش عملکرد را برای پرس‌وجوهای تجمیعی پیچیده در مجموعه‌های بزرگ شناسایی می‌کنند. این یافته‌ها انگیزه ما برای گنجاندن هر دو الگوی پرس‌وجوی ساده و پیچیده در مجموعه بنچمارک ما بود.

\subsection{تحقیق در پایگاه‌داده‌های چندمدلی}

پایگاه‌داده‌های چندمدلی یک حوزه تحقیقاتی نسبتاً جدید را نشان می‌دهند. \lr{Lu} و همکاران \cite{lu2019multi} یک بررسی جامع ارائه می‌دهند که بین سیستم‌های چندمدلی بومی (طراحی شده برای چندین مدل از ابتدا) و سیستم‌های بازسازی‌شده (پایگاه‌داده‌های تک‌مدلی که برای پشتیبانی از مدل‌های اضافی توسعه یافته‌اند) تمایز قائل می‌شوند.

پیامدهای عملکردی معماری‌های چندمدلی تحقیقات تجربی محدودی دریافت کرده‌اند. \lr{Ghazal} و همکاران \cite{ghazal2013bigbench} بنچمارک‌هایی را برای تحلیل‌های چندمدلی پیشنهاد کردند اما عمدتاً بر پلتفرم‌های کلان‌داده متمرکز بودند تا پایگاه‌داده‌های عملیاتی. \lr{Wingerath} و همکاران \cite{wingerath2021nosql} الگوهای ماندگاری چندزبانه را بررسی کردند و سربار هماهنگی را به عنوان یک چالش کلیدی در استفاده از چندین پایگاه‌داده تخصصی شناسایی کردند.

تحقیقات خاص \lr{ArangoDB} در ادبیات آکادمیک پراکنده است. مستندات و مقاله‌های سفید از \lr{ArangoDB GmbH} \cite{arangodb2023documentation} تصمیمات معماری را توصیف می‌کنند اما فاقد اعتبارسنجی مستقل عملکرد هستند. بنچمارک‌های اجتماعی وجود دارند اما اغلب فاقد دقت روش‌شناختی یا معیارهای مقایسه‌ای هستند.

\subsection{عملکرد پایگاه‌داده گراف}

عملکرد پایگاه‌داده گراف به دلیل ماهیت عملیات پیمایش ویژگی‌های منحصر به فردی دارد. \lr{Holzschuher} و \lr{Peinl} \cite{holzschuher2013performance} نشان دادند که پایگاه‌داده‌های گراف بومی مانند \lr{Neo4j} برای پیمایش‌های عمیق به طور قابل توجهی از پایگاه‌داده‌های رابطه‌ای بهتر عمل می‌کنند اما برای پرس‌وجوهای کم‌عمق همگرایی عملکردی را نشان دادند.

کارهای اخیر \cite{angles2020foundations} روی زبان‌های پرس‌وجوی گراف و تکنیک‌های بهینه‌سازی، وضعیت هنر را پیش برده است. با این حال، اکثر مطالعات بر پایگاه‌داده‌های گراف تخصصی تمرکز دارند تا سیستم‌های چندمدلی که از عملیات گراف پشتیبانی می‌کنند.

\subsection{شکاف تحقیقاتی}

در حالی که ادبیات موجود به طور گسترده پایگاه‌داده‌های \lr{NoSQL} تخصصی را پوشش می‌دهد، تحلیل جامع عملکرد پایگاه‌داده‌های چندمدلی بومی همچنان محدود است. سوالاتی در مورد جریمه (یا سود) عملکردی پشتیبانی چندمدلی، به ویژه برای بارهای کاری که چندین مدل داده را ترکیب می‌کنند، فاقد پاسخ‌های تجربی است. این مطالعه این شکاف را از طریق بنچمارک‌گیری سیستماتیک \lr{ArangoDB} در برابر پایگاه‌داده‌های تخصصی پیشرو در رده خود برطرف می‌کند.

\section{معماری و ویژگی‌های \lr{ArangoDB}}

\subsection{بنیاد چندمدلی}

\lr{ArangoDB} یک معماری چندمدلی بومی را پیاده‌سازی می‌کند که در آن اسناد، گراف‌ها و جفت‌های کلید-مقدار شهروندان درجه یک هستند نه افزودنی‌هایی به یک مدل هسته‌ای. این فلسفه طراحی بر هر لایه از سیستم، از موتور ذخیره‌سازی تا بهینه‌سازی پرس‌وجو، تاثیر می‌گذارد.

\subsubsection{مدل داده یکپارچه}

در هسته خود، \lr{ArangoDB} تمام داده‌ها را به عنوان اسناد \lr{JSON} ذخیره می‌کند. یال‌های گراف به عنوان اسنادی با ویژگی‌های خاص \texttt{\_from} و \texttt{\_to} که به اسناد راس ارجاع می‌دهند، نمایش داده می‌شوند. دسترسی کلید-مقدار از طریق جستجوی مستقیم سند توسط کلید اصلی حاصل می‌شود. این مدل ذخیره‌سازی یکپارچه امکانات زیر را فراهم می‌کند:

\begin{itemize}
    \item \textbf{انعطاف‌پذیری نوع}: رئوس و یال‌ها می‌توانند ویژگی‌های دلخواه داشته باشند.
    \item \textbf{یکپارچگی پرس‌وجو}: پیوندهای (\lr{Join}) بدون درز بین مجموعه‌هایی از انواع مختلف.
    \item \textbf{ایندکس‌گذاری سازگار}: انواع ایندکس یکسان قابل اجرا در همه مدل‌ها.
\end{itemize}

\subsubsection{انواع مجموعه (\lr{Collection})}

\lr{ArangoDB} دو نوع مجموعه تعریف می‌کند:
\begin{enumerate}
    \item \textbf{مجموعه‌های سند}: مجموعه‌های استاندارد ذخیره‌کننده اسناد \lr{JSON}، مشابه مجموعه‌های \lr{MongoDB}.
    \item \textbf{مجموعه‌های یال}: مجموعه‌های تخصصی ذخیره‌کننده یال‌های گراف با ارجاعات اجباری \texttt{\_from} و \texttt{\_to}.
\end{enumerate}

\subsection{زبان پرس‌وجوی \lr{ArangoDB (AQL)}}

\lr{AQL} یک نحو شبه \lr{SQL} اعلانی برای همه مدل‌های داده فراهم می‌کند. ویژگی‌های کلیدی عبارتند از:

\subsubsection{پرس‌وجوهای سند}
\begin{lstlisting}[caption=AQL Document Query Example]
FOR user IN users
  FILTER user.age > 25
  AND user.country == "USA"
  SORT user.name
  LIMIT 100
  RETURN user
\end{lstlisting}

\subsubsection{پیمایش‌های گراف}
\begin{lstlisting}[caption=AQL Graph Traversal Example]
FOR v, e, p IN 1..3 OUTBOUND
  'users/john' GRAPH 'social'
  FILTER v.active == true
  RETURN {
    person: v.name,
    path_length: LENGTH(p.vertices)
  }
\end{lstlisting}

\subsubsection{پرس‌وجوهای چندمدلی}
مزیت متمایز \lr{AQL} در پرس‌وجوهایی که مدل‌ها را ترکیب می‌کنند، ظاهر می‌شود:
\begin{lstlisting}[caption=Multi-model Query Example]
FOR user IN users
  FOR product IN 1..1 OUTBOUND
    user purchases
  FILTER product.price > 100
  COLLECT category = product.category
  AGGREGATE total = SUM(product.price)
  RETURN {category, total}
\end{lstlisting}

این پرس‌وجو فیلترینگ سند، پیمایش گراف و تجمیع را در یک دستور واحد ترکیب می‌کند --- عملیاتی که در معماری چندزبانه به چندین پرس‌وجو در پایگاه‌داده‌های مختلف نیاز دارد.

\subsection{موتور ذخیره‌سازی}

\lr{ArangoDB}\ از \lr{RocksDB}\ به عنوان موتور ذخیره‌سازی پیش‌فرض خود استفاده می‌کند (جایگزین موتور قبلی \lr{MMFiles}). \lr{RocksDB}\ موارد زیر را ارائه می‌دهد:

\begin{itemize}
    \item \textbf{معماری درخت ادغام ساختاریافته با لاگ (\lr{LSM})}: بهینه شده برای بارهای کاری سنگین نوشتن.
    \item \textbf{فشرده‌سازی}: کاهش ردپای ذخیره‌سازی.
    \item \textbf{سازگاری قابل تنظیم}: سیاست‌های همگام‌سازی قابل پیکربندی که دوام و عملکرد را متعادل می‌کنند.
\end{itemize}

\subsection{مکانیسم‌های ایندکس‌گذاری}

\lr{ArangoDB} از چندین نوع ایندکس پشتیبانی می‌کند که در تمام انواع مجموعه قابل استفاده هستند:

\begin{table}[h]
\centering
\caption{انواع ایندکس \lr{ArangoDB}\ و موارد استفاده}
\label{tab:indexes}%
\begin{tabular}{@{}lll@{}}
\toprule
نوع ایندکس & بهترین برای & پیچیدگی \\ \midrule
\lr{Persistent} & پرس‌وجوهای عمومی & $O(\log n)$ \\
\lr{Hash} & جستجوهای تساوی & $O(1)$ \\
\lr{Skiplist} & پرس‌وجوهای دامنه‌ای & $O(\log n)$ \\
\lr{Fulltext} & جستجوی متن & $O(k)$ \\
\lr{Geo} & پرس‌وجوهای مکانی & $O(\log n)$ \\
\lr{TTL} & اسناد منقضی‌شونده & $O(1)$ \\ \bottomrule
\end{tabular}
\end{table}

مجموعه‌های یال به طور خودکار ایندکس‌های \lr{Hash} را روی ویژگی‌های \texttt{\_from} و \texttt{\_to} ایجاد می‌کنند که پیمایش‌های گراف را تسریع می‌کند.

\subsection{خوشه‌بندی و مقیاس‌پذیری}

معماری خوشه \lr{ArangoDB} از طراحی بدون ارباب (\lr{Masterless}) با سه نوع گره استفاده می‌کند:

\begin{enumerate}
    \item \textbf{عامل‌ها (\lr{Agents})}: نگهداری پیکربندی خوشه با استفاده از اجماع \lr{Raft}.
    \item \textbf{هماهنگ‌کننده‌ها (\lr{Coordinators})}: مدیریت درخواست‌های کلاینت و هماهنگی پرس‌وجو.
    \item \textbf{سرورهای پایگاه‌داده (\lr{DB-Servers})}: ذخیره و مدیریت شاردهای داده.
\end{enumerate}

\subsubsection{توزیع داده}

مجموعه‌ها به طور خودکار با استفاده از درهم‌سازی سازگار (\lr{Consistent Hashing}) در سرورهای \lr{DB} شارد می‌شوند. فاکتور تکرار و تعداد شاردها برای هر مجموعه قابل پیکربندی است که امکان بهینه‌سازی دقیق عملکرد را فراهم می‌کند.

برای مجموعه‌های گراف، \lr{ArangoDB} دو استراتژی شاردینگ ارائه می‌دهد:
\begin{itemize}
    \item \textbf{شاردینگ تصادفی}: توزیع استاندارد مبتنی بر هش.
    \item \textbf{گراف‌های هوشمند (\lr{Smart Graphs})}: هم‌مکان کردن رئوس و یال‌های مرتبط برای به حداقل رساندن پرش‌های شبکه در طول پیمایش‌ها.
\end{itemize}

\subsection{پشتیبانی از تراکنش}

\lr{ArangoDB} تراکنش‌های \lr{ACID} را با ویژگی‌های زیر ارائه می‌دهد:

\begin{itemize}
    \item \textbf{تراکنش‌های تک‌سند}: همیشه مطابق با \lr{ACID}.
    \item \textbf{تراکنش‌های چندسند}: \lr{ACID} در یک مجموعه واحد.
    \item \textbf{تراکنش‌های چندمجموعه}: \lr{ACID} در استقرارهای تک‌سرور؛ سازگاری نهایی (\lr{Eventual Consistency}) در خوشه‌ها (با استثنائاتی برای گراف‌های هوشمند).
\end{itemize}

این مدل تراکنش نشان‌دهنده موازنه‌ای بین تضمین‌های سازگاری و مقیاس‌پذیری خوشه است که \lr{ArangoDB} را بین سیستم‌های کاملاً سازگار (\lr{RDBMS} سنتی) و پایگاه‌داده‌های \lr{NoSQL} با سازگاری نهایی قرار می‌دهد.

\subsection{بهینه‌سازی پرس‌وجو}

بهینه‌ساز \lr{AQL} از استراتژی‌های متعددی استفاده می‌کند:

\begin{enumerate}
    \item \textbf{انتخاب ایندکس}: انتخاب خودکار ایندکس‌های بهینه.
    \item \textbf{بهینه‌سازی الحاق}: مرتب‌سازی مجدد الحاق‌ها برای کارایی.
    \item \textbf{هل دادن فیلتر به پایین}: انتقال شروط (\lr{Predicates}) به نزدیکی دسترسی داده.
    \item \textbf{اجرای موازی}: توزیع اجرای پرس‌وجو در شاردهای مختلف.
\end{enumerate}

پروفایلینگ پرس‌وجو برنامه اجرا را نشان می‌دهد و توسعه‌دهندگان را قادر می‌سازد گلوگاه‌های عملکرد را شناسایی کنند:

\begin{lstlisting}[caption=Query Profiling Example]
FOR user IN users
  FILTER user.status == "active"
  RETURN user
/* Execution plan uses 
   persistent index on status */
\end{lstlisting}

\section{روش‌شناسی تجربی}

\subsection{اصول طراحی بنچمارک}

مجموعه بنچمارک ما از اصول زیر پیروی می‌کند:

\begin{enumerate}
    \item \textbf{تنوع بار کاری}: پوشش سناریوهای سنگین-خواندن، سنگین-نوشتن و متعادل.
    \item \textbf{واقع‌گرایی داده‌ها}: استفاده از توزیع‌های داده و الگوهای پرس‌وجوی واقعی.
    \item \textbf{انصاف}: اطمینان از بهینه‌سازی قابل مقایسه در تمام پایگاه‌داده‌ها.
    \item \textbf{تکرارپذیری}: مستندسازی تمام پارامترهای پیکربندی و روش‌های تست.
    \item \textbf{اعتبار آماری}: اجراهای متعدد با بازه‌های اطمینان.
\end{enumerate}

\subsection{انتخاب پایگاه‌داده و نسخه‌ها}

ما پایگاه‌داده‌های زیر را برای مقایسه انتخاب کردیم:

\begin{table}[h]
\centering
\caption{سیستم‌های پایگاه‌داده تست‌شده و نسخه‌ها}
\label{tab:systems}%
\begin{tabular}{@{}lll@{}}
\toprule
پایگاه‌داده & نسخه & مدل اصلی \\ \midrule
\lr{ArangoDB} & \lr{3.11.2} & چندمدلی \\
\lr{MongoDB} & \lr{7.0.2} & سند \\
\lr{Neo4j} & \lr{5.12.0} & گراف \\
\lr{Redis} & \lr{7.2.1} & کلید-مقدار \\
\lr{Cassandra} & \lr{4.1.3} & خانواده ستونی \\ \bottomrule
\end{tabular}
\end{table}

تمام پایگاه‌داده‌ها با تنظیمات توصیه‌شده تولید پیکربندی شدند و تخصیص حافظه به \lr{۱۶} گیگابایت برای هر نمونه نرمال‌سازی شد.

\subsection{سخت‌افزار و محیط}

\textbf{تست‌های تک‌گره:}
\begin{itemize}
    \item پردازنده: \lr{AMD EPYC 7543} (۳۲ هسته @ ۲.۸ گیگاهرتز)
    \item حافظه رم: \lr{۶۴}\ گیگابایت \lr{DDR4}
    \item ذخیره‌سازی: \lr{۱} ترابایت \lr{NVMe SSD}
    \item سیستم عامل: \lr{Ubuntu 22.04 LTS}
\end{itemize}

\textbf{تست‌های خوشه:}
\begin{itemize}
    \item خوشه \lr{۳} گره‌ای (همان سخت‌افزار برای هر گره)
    \item اتصال شبکه \lr{۱۰} گیگابیت بر ثانیه
    \item متعادل‌کننده بار \lr{Round-robin}
\end{itemize}

\subsection{ویژگی‌های مجموعه داده}

ما سه مجموعه داده اصلی تولید کردیم:

\subsubsection{مجموعه داده سند}
\begin{itemize}
    \item \lr{۱۰} میلیون سند کاربر.
    \item میانگین اندازه: \lr{۲} کیلوبایت.
    \item اسکیما: \texttt{\{id, name, email, age, country, registration\_date, preferences\}}.
    \item مجموعه داده ثانویه: \lr{۵۰} میلیون سند محصول (میانگین \lr{۱.۵} کیلوبایت).
\end{itemize}

\subsubsection{مجموعه داده گراف}
\begin{itemize}
    \item شبکه اجتماعی: \lr{۱} میلیون راس، \lr{۱۰} میلیون یال.
    \item توزیع درجه قانون توان (گراف اجتماعی واقعی).
    \item میانگین درجه: \lr{۱۰}، حداکثر درجه: \lr{۵۰۰۰}.
    \item ویژگی‌های یال: \texttt{\{timestamp, relationship\_type\}}.
\end{itemize}

\subsubsection{مجموعه داده کلید-مقدار}
\begin{itemize}
    \item \lr{۲۰} میلیون جفت کلید-مقدار.
    \item توزیع کلید: زیفیان (\lr{Zipfian}) (تقلید از الگوهای دسترسی دنیای واقعی).
    \item اندازه مقادیر: \lr{۱۰۰} بایت تا \lr{۱۰} کیلوبایت (توزیع نرمال حدود \lr{۱} کیلوبایت).
\end{itemize}

\subsection{مشخصات بار کاری}

\subsubsection{بارهای کاری مبتنی بر \lr{YCSB}}

ما بارهای کاری \lr{A} تا \lr{F} را از \lr{YCSB} اقتباس کردیم:

\begin{table}[h]
\centering
\caption{مشخصات بارهای کاری \lr{YCSB}}
\label{tab:ycsb}%
\small
\begin{tabular}{@{}llll@{}}
\toprule
بار کاری & خواندن & به‌روزرسانی & توضیحات \\ \midrule
\lr{A} & \lr{50\%} & \lr{50\%} & متعادل \\
\lr{B} & \lr{95\%} & \lr{5\%} & سنگین-خواندن \\
\lr{C} & \lr{100\%} & \lr{0\%} & فقط-خواندن \\
\lr{D} & \lr{95\%} & \lr{5\%} & خواندن-آخرین‌ها \\
\lr{E} & \lr{95\%} & \lr{5\%} & سنگین-پیمایش (\lr{Scan}) \\
\lr{F} & \lr{50\%} & \lr{50\%} & خواندن-تغییر-نوشتن \\ \bottomrule
\end{tabular}
\end{table}

\subsubsection{بارهای کاری خاص گراف}

\begin{itemize}
    \item \textbf{\lr{G1}}: پیمایش‌های کوتاه (\lr{۱-۲} گام)، همزمانی بالا.
    \item \textbf{\lr{G2}}: پیمایش‌های متوسط (\lr{۳-۴} گام)، همزمانی متوسط.
    \item \textbf{\lr{G3}}: پیمایش‌های عمیق (\lr{۵-۷} گام)، همزمانی کم.
    \item \textbf{\lr{G4}}: تطبیق الگو (تشخیص مثلث، یافتن جامعه).
    \item \textbf{\lr{G5}}: پرس‌وجوهای ترکیبی گراف-سند (پیمایش + فیلترینگ).
\end{itemize}

\subsubsection{بارهای کاری چندمدلی}

\begin{itemize}
    \item \textbf{\lr{MM1}}: جستجوی سند $\leftarrow$ پیمایش گراف $\leftarrow$ تجمیع.
    \item \textbf{\lr{MM2}}: پیمایش گراف $\leftarrow$ الحاق سند $\leftarrow$ فیلترینگ.
    \item \textbf{\lr{MM3}}: دسترسی کلید-مقدار $\leftarrow$ گسترش گراف $\leftarrow$ غنی‌سازی سند.
\end{itemize}

\subsection{معیارهای عملکرد}

ما موارد زیر را اندازه‌گیری کردیم:

\begin{enumerate}
    \item \textbf{توان عملیاتی}: عملیات در ثانیه (\lr{ops/sec}).
    \item \textbf{تاخیر}: توزیع زمان پاسخ (\lr{p50, p95, p99}).
    \item \textbf{مقیاس‌پذیری}: عملکرد در برابر اندازه خوشه.
    \item \textbf{بهره‌وری منابع}: \lr{CPU}، حافظه، \lr{I/O} دیسک.
    \item \textbf{زمان بارگذاری داده}: عملکرد وارد کردن انبوه (\lr{Bulk Import}).
\end{enumerate}

\subsection{تحلیل آماری}

هر آزمایش \lr{۵} بار تکرار شد. نتایج گزارش می‌دهند:
\begin{itemize}
    \item مقادیر میانه (مقاوم در برابر داده‌های پرت).
    \item بازه‌های اطمینان \lr{۹۵\%}.
    \item تست معناداری آماری (آزمون \lr{Mann-Whitney U}، $p < 0.05$).
\end{itemize}

\section{تحلیل عملکرد و نتایج}

\subsection{عملکرد ذخیره‌ساز سند}

\subsubsection{عملیات \lr{CRUD}}

جدول~\ref{tab:doc-crud} توان عملیاتی را برای عملیات پایه سند در مقایسه \lr{ArangoDB}\ و \lr{MongoDB}\ نشان می‌دهد. برای نشان دادن بهتر این نتایج، شکل~\ref{fig:doc-crud} نمودار میله‌ای گروه‌بندی شده توان عملیاتی \lr{CRUD}\ را نمایش می‌دهد.

\begin{table}[h]
\centering
\caption{توان عملیاتی \lr{CRUD}\ سند (عملیات در ثانیه)}
\label{tab:doc-crud}%
\begin{tabular}{@{}lrr@{}}
\toprule
عملیات & \lr{ArangoDB} & \lr{MongoDB} \\ \midrule
درج تکی & \lr{12,450} & \lr{13,200} \\
درج گروهی (\lr{1000}) & \lr{125,000} & \lr{142,000} \\
خواندن نقطه‌ای & \lr{45,300} & \lr{48,100} \\
پرس‌وجوی دامنه‌ای & \lr{8,900} & \lr{9,400} \\
به‌روزرسانی & \lr{11,200} & \lr{12,800} \\
حذف & \lr{10,800} & \lr{11,500} \\ \bottomrule
\end{tabular}
\end{table}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.9]
        \begin{scope}
            \pgfmathsetmacro{\barw}{0.25}
            \pgfmathsetmacro{\sep}{0.9}

            % x-axis labels
            \foreach \i/\name in {0/Insert,1/Bulk,2/Read,3/Range,4/Update,5/Delete} {
                \node[rotate=45, anchor=west] at (\i*\sep,-0.3) {\scriptsize \name};
            }

            % y-axis
            \draw[->] (-0.7,0) -- (-0.7,4.2);
            \foreach \y/\label in {0/0,1/25k,2/50k,3/75k,4/100k} {
                \draw (-0.72,\y) -- (-0.68,\y);
                \node[left] at (-0.72,\y) {\scriptsize \label};
            }

            % scale (rough, for illustration)
            \def\Ains{12450/25000}
            \def\Mins{13200/25000}
            \def\Abulk{125000/25000}
            \def\Mbulk{142000/25000}
            \def\Aread{45300/25000}
            \def\Mread{48100/25000}
            \def\Arange{8900/25000}
            \def\Mrange{9400/25000}
            \def\Aupd{11200/25000}
            \def\Mupd{12800/25000}
            \def\Adel{10800/25000}
            \def\Mdel{11500/25000}

            % ArangoDB bars (blue)
            \foreach \i/\val in {
                0/\Ains,
                1/\Abulk,
                2/\Aread,
                3/\Arange,
                4/\Aupd,
                5/\Adel} {
                \pgfmathsetmacro{\h}{\val}
                \fill[blue!60] (\i*\sep-\barw,0) rectangle ++(\barw,\h);
            }

            % MongoDB bars (orange)
            \foreach \i/\val in {
                0/\Mins,
                1/\Mbulk,
                2/\Mread,
                3/\Mrange,
                4/\Mupd,
                5/\Mdel} {
                \pgfmathsetmacro{\h}{\val}
                \fill[orange!70] (\i*\sep,0) rectangle ++(\barw,\h);
            }

            % legend
            \draw[blue!60] (3.9,3.5) rectangle ++(0.2,0.15);
            \node[anchor=west] at (4.1,3.575) {\scriptsize ArangoDB};
            \draw[orange!70] (3.9,3.2) rectangle ++(0.2,0.15);
            \node[anchor=west] at (4.1,3.275) {\scriptsize MongoDB};
        \end{scope}
    \end{tikzpicture}
    \caption{مقایسه توان عملیاتی \lr{CRUD}\ سند بین \lr{ArangoDB}\ و \lr{MongoDB}\ (مقیاس منطقی).}
    \label{fig:doc-crud}%
\end{figure}

\textbf{یافته‌های کلیدی:}
\begin{itemize}
    \item \lr{MongoDB} حدود \lr{۵} تا \lr{۱۳} درصد توان عملیاتی بالاتری برای عملیات پایه \lr{CRUD} دارد، که بیشترین تفاوت در بارهای کاری درج گروهی به دلیل مسیر نوشتن بسیار بهینه شده آن مشاهده می‌شود.
    \item با وجود این، \lr{ArangoDB} تقریباً \lr{۸۵} تا \lr{۹۵} درصد از توان عملیاتی \lr{MongoDB} را در تمام عملیات \lr{CRUD} حفظ می‌کند که نشان می‌دهد سربار قابلیت‌های چندمدلی آن برای بارهای کاری صرفاً سندی نسبتاً کم است.
    \item شکاف عملکرد در شرایط تست ما از نظر آماری معنی‌دار است اما برای بسیاری از کاربردهای دنیای واقعی عملاً متوسط است، به خصوص زمانی که با توانایی \lr{ArangoDB} در پشتیبانی از مدل‌های داده اضافی و پرس‌وجوهای پیچیده‌تر در همان سیستم سنجیده شود.
\end{itemize}

\subsubsection{تجمیع‌های پیچیده}

عملکرد تجمیع برای بارهای کاری سند در جدول~\ref{tab:aggregations} خلاصه شده است. برای ارائه یک مقایسه بصری، شکل~\ref{fig:doc-agg} تاخیر نسبی را برای \lr{ArangoDB}\ و \lr{MongoDB}\ در انواع مختلف تجمیع نشان می‌دهد.

\begin{table}[h]
\centering
\caption{تاخیر پرس‌وجوی تجمیع (میلی‌ثانیه)}
\label{tab:aggregations}%
\begin{tabular}{@{}lrr@{}}
\toprule
نوع پرس‌وجو & \lr{ArangoDB} & \lr{MongoDB} \\ \midrule
\lr{GROUP BY + COUNT} & \lr{142} & \lr{138} \\
\lr{Multi-stage pipeline} & \lr{285} & \lr{310} \\
\lr{Join-like operation} & \lr{420} & \lr{580} \\
\lr{Nested aggregation} & \lr{520} & \lr{650} \\ \bottomrule
\end{tabular}
\end{table}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.9]
        \begin{scope}
            \pgfmathsetmacro{\barw}{0.25}
            \pgfmathsetmacro{\sep}{1.1}

            \foreach \i/\name in {0/GroupBy,1/Multi,2/Join-like,3/Nested} {
                \node[rotate=45, anchor=west] at (\i*\sep,-0.3) {\scriptsize \name};
            }

            \draw[->] (-0.7,0) -- (-0.7,4.3);
            \foreach \y/\label in {0/0,1/200,2/400,3/600,4/800} {
                \draw (-0.72,\y) -- (-0.68,\y);
                \node[left] at (-0.72,\y) {\scriptsize \label};
            }

            % values scaled by /200
            \def\Agb{142/200}
            \def\Mgb{138/200}
            \def\Amult{285/200}
            \def\Mmult{310/200}
            \def\Ajoin{420/200}
            \def\Mjoin{580/200}
            \def\Anest{520/200}
            \def\Mnest{650/200}

            % ArangoDB (blue)
            \foreach \i/\val in {
                0/\Agb,
                1/\Amult,
                2/\Ajoin,
                3/\Anest} {
                \pgfmathsetmacro{\h}{\val}
                \fill[blue!60] (\i*\sep-\barw,0) rectangle ++(\barw,\h);
            }

            % MongoDB (orange)
            \foreach \i/\val in {
                0/\Mgb,
                1/\Mmult,
                2/\Mjoin,
                3/\Mnest} {
                \pgfmathsetmacro{\h}{\val}
                \fill[orange!70] (\i*\sep,0) rectangle ++(\barw,\h);
            }

            \draw[blue!60] (3.7,3.7) rectangle ++(0.2,0.15);
            \node[anchor=west] at (3.9,3.775) {\scriptsize ArangoDB};
            \draw[orange!70] (3.7,3.4) rectangle ++(0.2,0.15);
            \node[anchor=west] at (3.9,3.475) {\scriptsize MongoDB};
        \end{scope}
    \end{tikzpicture}
    \caption{مقایسه تاخیر پرس‌وجوی تجمیع بین \lr{ArangoDB}\ و \lr{MongoDB}\ (مقیاس نسبی).}
    \label{fig:doc-agg}%
\end{figure}

\textbf{تحلیل:}
\begin{itemize}
    \item برای الگوهای تجمیع ساده مانند \emph{\lr{GROUP BY + COUNT}}، \lr{MongoDB} به طور ناچیزی سریع‌تر است (حدود \lr{۲-۳\%})، که با بهینه‌سازی آن برای مراحل ساده پایپ‌لاین سازگار است.
    \item با پیچیده‌تر شدن پایپ‌لاین‌های تجمیع پایپ‌لاین‌های چندمرحله‌ای، پرس‌وجوهای شبیه به الحاق، تجمیع‌های تو در تو، \lr{ArangoDB} شروع به پیشی گرفتن از \lr{MongoDB} می‌کند، با بهبودهای تاخیر در بازه \lr{۸-۲۰\%}.
    \item در تجمیع‌های شبیه به الحاق که الحاق‌های چندمجموعه‌ای را تقریب می‌زنند، بهینه‌ساز پرس‌وجوی \lr{ArangoDB} موثرتر به نظر می‌رسد و حدود \lr{۲۸\%} تاخیر کمتری را نسبت به \lr{MongoDB} تحت تنظیمات یکسان مجموعه داده و ایندکس به دست می‌آورد.
    \item این نتایج نشان می‌دهد که در حالی که \lr{MongoDB} در تجمیع‌های بسیار ساده کمی قوی‌تر است، بهینه‌ساز پرس‌وجوی \lr{ArangoDB} با افزایش پیچیدگی ساختاری و ماهیت چندمجموعه‌ای پرس‌وجوها عملکرد بهتری ارائه می‌دهد.
\end{itemize}

\subsubsection{نتایج بار کاری \lr{YCSB}}

بارهای کاری مبتنی بر \lr{YCSB}\ رفتار مقایسه‌ای را برای الگوهای کاربردی معمول برجسته می‌کنند. جدول~\ref{tab:ycsb-results} میانگین توان عملیاتی را برای \lr{ArangoDB}\ و \lr{MongoDB}\ در بارهای کاری \lr{A--F}\ گزارش می‌دهد. شکل~\ref{fig:ycsb-bar} این تفاوت‌ها را به تصویر می‌کشد.

\begin{table}[h]
\centering
\caption{مقایسه توان عملیاتی \lr{YCSB}\ (\lr{ops/sec})}
\label{tab:ycsb-results}%
\begin{tabular}{@{}lrr@{}}
\toprule
بار کاری & \lr{ArangoDB} & \lr{MongoDB} \\ \midrule
\lr{A (50\% R/W)} & \lr{28,400} & \lr{30,200} \\
\lr{B (95\% Read)} & \lr{41,200} & \lr{43,800} \\
\lr{C (100\% Read)} & \lr{45,100} & \lr{48,000} \\
\lr{D (Read-latest)} & \lr{39,800} & \lr{41,500} \\
\lr{E (Scan)} & \lr{7,200} & \lr{7,800} \\
\lr{F (RMW)} & \lr{15,600} & \lr{16,900} \\ \bottomrule
\end{tabular}
\end{table}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.9]
        \begin{scope}
            \pgfmathsetmacro{\barw}{0.25}
            \pgfmathsetmacro{\sep}{0.9}

            \foreach \i/\name in {0/A,1/B,2/C,3/D,4/E,5/F} {
                \node[anchor=west, rotate=45] at (\i*\sep,-0.3) {\scriptsize \name};
            }

            \draw[->] (-0.7,0) -- (-0.7,4.2);
            \foreach \y/\label in {0/0,1/10k,2/20k,3/30k,4/40k} {
                \draw (-0.72,\y) -- (-0.68,\y);
                \node[left] at (-0.72,\y) {\scriptsize \label};
            }

            % scale by /10000
            \def\Aa{28400/10000}
            \def\Ma{30200/10000}
            \def\Ab{41200/10000}
            \def\Mb{43800/10000}
            \def\Ac{45100/10000}
            \def\Mc{48000/10000}
            \def\Ad{39800/10000}
            \def\Md{41500/10000}
            \def\Ae{7200/10000}
            \def\Me{7800/10000}
            \def\Af{15600/10000}
            \def\Mf{16900/10000}

            % ArangoDB
            \foreach \i/\val in {
                0/\Aa,
                1/\Ab,
                2/\Ac,
                3/\Ad,
                4/\Ae,
                5/\Af} {
                \pgfmathsetmacro{\h}{\val}
                \fill[blue!60] (\i*\sep-\barw,0) rectangle ++(\barw,\h);
            }

            % MongoDB
            \foreach \i/\val in {
                0/\Ma,
                1/\Mb,
                2/\Mc,
                3/\Md,
                4/\Me,
                5/\Mf} {
                \pgfmathsetmacro{\h}{\val}
                \fill[orange!70] (\i*\sep,0) rectangle ++(\barw,\h);
            }

            \draw[blue!60] (3.8,3.7) rectangle ++(0.2,0.15);
            \node[anchor=west] at (4.0,3.775) {\scriptsize ArangoDB};
            \draw[orange!70] (3.8,3.4) rectangle ++(0.2,0.15);
            \node[anchor=west] at (4.0,3.475) {\scriptsize MongoDB};
        \end{scope}
    \end{tikzpicture}
    \caption{مقایسه توان عملیاتی \lr{YCSB} برای \lr{ArangoDB} و \lr{MongoDB} در بارهای کاری \lr{A--F}.}
    \label{fig:ycsb-bar}
\end{figure}

\textbf{تفسیر:}
\begin{itemize}
    \item در تمام بارهای کاری \lr{YCSB}، پایگاه‌داده \lr{MongoDB} به طور مداوم با اختلاف حدود \lr{۵} تا \lr{۱۰} درصد از \lr{ArangoDB} بهتر عمل می‌کند، که مشاهدات قبلی \lr{CRUD} را در شرایط دسترسی ترکیبی و سنگین-خواندن تایید می‌کند.
    \item شکاف نسبی در بارهای کاری کاملاً خواندنی و عمدتاً خواندنی (\lr{B, C, D}) که در آن‌ها بهینه‌سازی‌های مسیر خواندن \lr{MongoDB} کاملاً مورد استفاده قرار می‌گیرند، مشهودتر است.
    \item برای بارهای کاری سنگین-پیمایش (\lr{Scan}) و خواندن-تغییر-نوشتن (\lr{E} و \lr{F})، تفاوت عملکرد کمی کاهش می‌یابد، که نشان می‌دهد با پیچیده‌تر و حالتمندتر شدن عملیات، سربار \lr{ArangoDB} نسبت به هزینه خود عملیات کمتر غالب می‌شود.
    \item نکته مهم این است که توانایی \lr{ArangoDB} برای پشتیبانی از مدل‌های اضافی (گراف و کلید-مقدار) در کنار این عملکرد سندی، جریمه کوچک توان عملیاتی را در سناریوهایی که پرس‌وجوهای چندمدلی مورد نیاز است، قابل قبول می‌سازد.
\end{itemize}

\subsection{عملکرد پایگاه‌داده گراف}

\subsubsection{عملکرد پیمایش}

بنچمارک‌های پیمایش گراف، \lr{ArangoDB} را با \lr{Neo4j} برای پیمایش‌های سطح اول (\lr{BFS}) با اعماق مختلف روی همان مجموعه داده شبکه اجتماعی مقایسه می‌کنند. جدول \ref{tab:graph-traversal} تاخیر \lr{p95} را گزارش می‌دهد، در حالی که شکل \ref{fig:graph-traversal} رشد مقایسه‌ای در تاخیر را با افزایش عمق پیمایش نشان می‌دهد.

\begin{table}[h]
\centering
\caption{تاخیر پیمایش گراف (میلی‌ثانیه، \lr{p95})}
\label{tab:graph-traversal}
\begin{tabular}{@{}lrr@{}}
\toprule
عمق پیمایش & \lr{ArangoDB} & \lr{Neo4j} \\ \midrule
\lr{۱} گام & \lr{2.3} & \lr{1.8} \\
\lr{۲} گام & \lr{8.5} & \lr{7.2} \\
\lr{۳} گام & \lr{24.1} & \lr{28.3} \\
\lr{۴} گام & \lr{68.2} & \lr{82.5} \\
\lr{۵} گام & \lr{185.4} & \lr{235.7} \\
\lr{۶} گام & \lr{521.3} & \lr{688.9} \\ \bottomrule
\end{tabular}
\end{table}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.9]
        \begin{scope}
            \draw[->] (0,0) -- (7,0) node[anchor=west] {\scriptsize عمق (گام)};
            \draw[->] (0,0) -- (0,4.5) node[anchor=south] {\scriptsize تاخیر (میلی‌ثانیه، \lr{p95}، مقیاس‌شده)};

            \foreach \x/\d in {1/1,2/2,3/3,4/4,5/5,6/6} {
                \draw (\x,0) -- (\x,-0.1);
                \node[below] at (\x,-0.1) {\scriptsize \d};
            }

            \foreach \y/\label in {0/0,1/100,2/200,3/400,4/800} {
                \draw (0,\y) -- (-0.05,\y);
                \node[left] at (-0.05,\y) {\scriptsize \label};
            }

            % scaled by /100
            \def\Aa{2.3/100}
            \def\Ab{8.5/100}
            \def\Ac{24.1/100}
            \def\Ad{68.2/100}
            \def\Ae{185.4/100}
            \def\Af{521.3/100}

            \def\Na{1.8/100}
            \def\Nb{7.2/100}
            \def\Nc{28.3/100}
            \def\Nd{82.5/100}
            \def\Ne{235.7/100}
            \def\Nf{688.9/100}

            % ArangoDB line
            \draw[blue!70, thick] (1,\Aa) -- (2,\Ab) -- (3,\Ac) -- (4,\Ad) -- (5,\Ae) -- (6,\Af);
            \foreach \x/\v in {1/\Aa,2/\Ab,3/\Ac,4/\Ad,5/\Ae,6/\Af} {
                \fill[blue!70] (\x,\v) circle (1.5pt);
            }

            % Neo4j line
            \draw[orange!90, thick, dashed] (1,\Na) -- (2,\Nb) -- (3,\Nc) -- (4,\Nd) -- (5,\Ne) -- (6,\Nf);
            \foreach \x/\v in {1/\Na,2/\Nb,3/\Nc,4/\Nd,5/\Ne,6/\Nf} {
                \fill[orange!90] (\x,\v) circle (1.5pt);
            }

            % legend
            \draw[blue!70, thick] (4.2,3.8) -- (4.6,3.8);
            \fill[blue!70] (4.4,3.8) circle (1.5pt);
            \node[anchor=west] at (4.7,3.8) {\scriptsize ArangoDB};

            \draw[orange!90, thick, dashed] (4.2,3.5) -- (4.6,3.5);
            \fill[orange!90] (4.4,3.5) circle (1.5pt);
            \node[anchor=west] at (4.7,3.5) {\scriptsize Neo4j};
        \end{scope}
    \end{tikzpicture}
    \caption{تاخیر پیمایش گراف (\lr{p95}) در مقابل عمق برای \lr{ArangoDB} و \lr{Neo4j} (مقادیر مقیاس‌شده).}
    \label{fig:graph-traversal}
\end{figure}

\textbf{مشاهدات کلیدی:}
\begin{itemize}
    \item برای پیمایش‌های کم‌عمق (\lr{۱-۲} گام)، \lr{Neo4j} حدود \lr{۱۵-۲۰\%} سریع‌تر از \lr{ArangoDB} است که منعکس‌کننده مزایای طرح ذخیره‌سازی گراف بومی و ساختارهای مجاورتی مبتنی بر اشاره‌گر تخصصی آن برای دسترسی به همسایگان نزدیک است.
    \item با افزایش عمق پیمایش به بیش از \lr{۳} گام، \lr{ArangoDB} شروع به پیشی گرفتن از \lr{Neo4j} می‌کند و تقریباً \lr{۱۵-۲۴\%} تاخیر کمتری برای پیمایش‌های \lr{۳-۶} گام به دست می‌آورد. این نشان می‌دهد که استراتژی‌های بهینه‌ساز و هرس کردن \lr{ArangoDB} برای محدود کردن فضای جستجو در پیمایش‌های عمیق‌تر در این مجموعه داده به طور خاص موثر هستند.
    \item منحنی رشد تاخیر برای \lr{Neo4j} در اعماق بیشتر تندتر از \lr{ArangoDB} است که نشان می‌دهد \lr{ArangoDB} با پیچیدگی پیمایش تحت بار کاری تست شده، به ویژه هنگامی که با شاردینگ گراف هوشمند در پیکربندی خوشه ترکیب می‌شود، با ظرافت بیشتری مقیاس می‌شود.
    \item در عمل، این بدان معناست که برنامه‌هایی که تحت سلطه پیمایش‌های کم‌عمق و نقطه‌مانند هستند ممکن است کمی به نفع \lr{Neo4j} باشند، در حالی که آن‌هایی که نیاز به اکتشاف گراف عمیق‌تر دارند (مانند انتشار نفوذ چندگامی یا الگوهای تقلب چندمرحله‌ای) می‌توانند از موتور پیمایش \lr{ArangoDB} بهره‌مند شوند، به ویژه زمانی که پرس‌وجوهای چندمدلی نیز مورد نیاز باشد.
\end{itemize}

\subsubsection{تطبیق الگو}

\begin{table}[h]
\centering
\caption{عملکرد پرس‌وجوی الگوی گراف (ثانیه)}
\label{tab:patterns}
\begin{tabular}{@{}lrr@{}}
\toprule
الگو & \lr{ArangoDB} & \lr{Neo4j} \\ \midrule
تشخیص مثلث & \lr{4.2} & \lr{3.8} \\
یافتن \lr{4-clique} & \lr{12.8} & \lr{11.3} \\
کوتاه‌ترین مسیر & \lr{0.15} & \lr{0.12} \\
همه مسیرها (عمق \lr{5}) & \lr{18.5} & \lr{22.1} \\
تشخیص جامعه & \lr{28.3} & \lr{25.7} \\ \bottomrule
\end{tabular}
\end{table}

تطبیق الگو نتایج متفاوتی را نشان می‌دهد، به طوری که \lr{Neo4j} عموماً برای الگوریتم‌های تخصصی سریع‌تر است اما \lr{ArangoDB} برای پرس‌وجوهای مبتنی بر مسیر رقابتی است. به طور کلی، \lr{Neo4j} مزیت کوچکی در تحلیل‌های گراف بسیار تخصصی حفظ می‌کند، در حالی که \lr{ArangoDB} برای بارهای کاری گراف عمومی به اندازه کافی کارآمد باقی می‌ماند، به ویژه جایی که ادغام با سایر مدل‌های داده مورد نیاز است.

\subsection{عملکرد کلید-مقدار}

مقایسه با \lr{Redis} (تک‌رشته‌ای، در حافظه) و \lr{Cassandra} (ستون عریض، پشتیبانی دیسک) در جدول \ref{tab:kv} خلاصه شده است.

\begin{table}[h]
\centering
\caption{توان عملیاتی کلید-مقدار (\lr{ops/sec})}
\label{tab:kv}
\begin{tabular}{@{}lrrr@{}}
\toprule
عملیات & \lr{ArangoDB} & \lr{Redis} & \lr{Cassandra} \\ \midrule
\lr{GET} & \lr{45,300} & \lr{98,200} & \lr{52,100} \\
\lr{SET} & \lr{12,450} & \lr{87,600} & \lr{48,300} \\
\lr{MGET (100 keys)} & \lr{8,900} & \lr{85,400} & \lr{7,200} \\
\lr{Range scan} & \lr{8,900} & \lr{N/A} & \lr{12,500} \\ \bottomrule
\end{tabular}
\end{table}

\textbf{تحلیل:}
\begin{itemize}
    \item \lr{Redis} در عملیات ساده \lr{GET/SET} (۲ تا ۷ برابر سریع‌تر) به دلیل طراحی در حافظه و حلقه رویداد تک‌رشته‌ای بسیار بهینه شده، غالب است.
    \item \lr{ArangoDB} و \lr{Cassandra}، هر دو با پشتیبانی دیسک، عملکرد خواندن قابل مقایسه‌ای را نشان می‌دهند، در حالی که \lr{Cassandra} در بارهای کاری سنگین-نوشتن به دلیل مدل ذخیره‌سازی بهینه شده برای الحاق (\lr{Append-optimized}) مزیت نشان می‌دهد.
    \item برخلاف \lr{Redis}، پایگاه‌داده \lr{ArangoDB} از معناشناسی پرس‌وجوی غنی‌تر (فیلترینگ، الحاق، تجمیع) روی داده‌های سبک کلید-مقدار پشتیبانی می‌کند که آن را زمانی که دسترسی ساده کلید-مقدار باید با الگوهای دسترسی پیچیده‌تر همزیستی داشته باشد، مناسب‌تر می‌سازد.
\end{itemize}

\subsection{عملکرد پرس‌وجوی چندمدلی}

\subsubsection{\lr{MM1}: پیشنهاد دوستان}

ما یک پرس‌وجوی سبک پیشنهاد دوست را که به عنوان یک کوئری چندمدلی واحد در \lr{ArangoDB} پیاده‌سازی شده است، با یک پیاده‌سازی چندزبانه معادل با استفاده از \lr{Neo4j} برای پیمایش گراف و \lr{MongoDB} برای جستجوی اسناد مقایسه می‌کنیم. پرس‌وجوی \lr{AQL} در \lr{ArangoDB} به صورت زیر است:

\begin{lstlisting}
FOR user IN users
  FILTER user._key == @userId
  FOR friend IN 1..1 OUTBOUND
    user friendships
  FOR product IN 1..1 OUTBOUND
    friend purchases
  FILTER product.category == @category
  COLLECT prod = product
  AGGREGATE count = LENGTH(prod)
  SORT count DESC
  LIMIT 10
  RETURN {product: prod, count}
\end{lstlisting}

تاخیر \lr{p95} اندازه‌گیری شده برای این پرس‌وجو در \lr{ArangoDB} برابر \lr{۳۵} میلی‌ثانیه است.

در معماری چندزبانه، منطق معادل نیاز دارد به:
\begin{enumerate}
    \item یک پرس‌وجوی \lr{Cypher} در \lr{Neo4j} برای بازیابی لیست شناسه‌های دوستان برای کاربر هدف (حدود \lr{۱۲} میلی‌ثانیه).
    \item یک پرس‌وجوی تجمیع در \lr{MongoDB} برای بازیابی محصولات خریداری شده توسط آن دوستان و فیلتر کردن بر اساس دسته‌بندی (حدود \lr{۱۸} میلی‌ثانیه).
    \item منطق سمت برنامه برای الحاق نتایج، تجمیع شمارش‌ها و مرتب‌سازی (حدود \lr{۸} میلی‌ثانیه).
\end{enumerate}

تاخیر ترکیبی \lr{p95} برای پایپ‌لاین چندزبانه، بدون احتساب سربار شبکه و سریال‌سازی، تقریباً \lr{۳۸} میلی‌ثانیه است؛ با احتساب میانگین سربار بین سرویس‌ها، تاخیر سرتاسری حدود \lr{۵۲} میلی‌ثانیه است.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.9]
        \begin{scope}
            \pgfmathsetmacro{\barw}{0.4}

            \draw[->] (0,0) -- (4,0) node[anchor=west] {\scriptsize رویکرد};
            \draw[->] (0,0) -- (0,3.5) node[anchor=south] {\scriptsize تاخیر (\lr{ms, p95})};

            \foreach \x/\name in {0.8/ArangoDB,2.6/Polyglot} {
                \node[anchor=mid, rotate=45] at (\x,-0.1) {\scriptsize \name};
            }

            \foreach \y/\label in {0/0,1/20,2/40,3/60} {
                \draw (0,\y) -- (-0.05,\y);
                \node[left] at (-0.05,\y) {\scriptsize \label};
            }

            % scale /20
            \def\Amm{35/20}
            \def\Pmm{52/20}

            \fill[blue!60] (0.8-\barw/2,0) rectangle ++(\barw,\Amm);
            \fill[orange!70] (2.6-\barw/2,0) rectangle ++(\barw,\Pmm);

            \draw[blue!60] (2.8,3.0) rectangle ++(0.2,0.15);
            \node[anchor=west] at (3.0,3.075) {\scriptsize ArangoDB};
            \draw[orange!70] (2.8,2.7) rectangle ++(0.2,0.15);
            \node[anchor=west] at (3.0,2.775) {\scriptsize Polyglot};
        \end{scope}
    \end{tikzpicture}
    \caption{تاخیر پیشنهاد دوست چندمدلی: \lr{ArangoDB} در مقابل چندزبانه (\lr{Neo4j + MongoDB +} برنامه).}
    \label{fig:mm-friend}
\end{figure}

\textbf{افزایش سرعت و تفسیر:}
\begin{itemize}
    \item \lr{ArangoDB} کل پرس‌وجوی پیشنهاد چندمدلی را در حدود \lr{۳۵} میلی‌ثانیه (\lr{p95}) اجرا می‌کند، در حالی که رویکرد چندزبانه به حدود \lr{۵۲} میلی‌ثانیه سرتاسری نیاز دارد که نشان‌دهنده تقریباً \lr{۳۳\%} کاهش تاخیر است.
    \item افزایش عملکرد عمدتاً به دلایل زیر است:
    \begin{itemize}
        \item عدم وجود رفت‌وبرگشت‌های شبکه بین چندین سیستم پایگاه‌داده.
        \item حذف سربار سریال‌سازی و دی‌سریال‌سازی هنگام انتقال نتایج میانی.
        \item توانایی بهینه‌ساز \lr{AQL} برای در نظر گرفتن کل برنامه پرس‌وجو در سراسر عملیات سند و گراف در یک موتور واحد.
    \end{itemize}
    \item این آزمایش نشان می‌دهد که، حتی اگر \lr{ArangoDB} ممکن است در ریزبنچمارک‌های سند یا گراف فردی کمی کندتر از سیستم‌های تخصصی باشد، اجرای یکپارچه چندمدلی آن می‌تواند از راهکارهای چندزبانه برای پرس‌وجوهای کاربردی واقعی و بین‌مدلی بهتر عمل کند.
\end{itemize}

\subsubsection{\lr{MM2}: تحلیل نفوذ اجتماعی}

برای یک بار کاری چندمدلی پیچیده‌تر، ما یک پرس‌وجوی تحلیل نفوذ اجتماعی را ارزیابی می‌کنیم که:
\begin{enumerate}
    \item اینفلوئنسرها را بر اساس معیارهای گراف شناسایی می‌کند (مثلاً کاربرانی با بیش از \lr{۱۰۰۰} دنبال‌کننده).
    \item این اینفلوئنسرها را با اسناد پست‌هایشان الحاق می‌کند.
    \item معیارهای تعامل (لایک، کامنت، اشتراک‌گذاری) را برای هر اینفلوئنسر تجمیع می‌کند.
\end{enumerate}

در \lr{ArangoDB}، این تحلیل به عنوان یک پرس‌وجوی \lr{AQL} واحد بیان می‌شود که پیمایش‌های گراف و الحاق‌های سند را ترکیب می‌کند. در یک معماری چندزبانه، این کار نیاز به پرس‌وجوهای جداگانه به یک پایگاه‌داده گراف و یک ذخیره‌ساز سند به همراه تجمیع سمت برنامه دارد.

جدول \ref{tab:multimodel} عملکرد مشاهده شده را خلاصه می‌کند و شکل \ref{fig:mm-influence} یک مقایسه بصری ارائه می‌دهد.

\begin{table}[h]
\centering
\caption{عملکرد پرس‌وجوی نفوذ اجتماعی چندمدلی}
\label{tab:multimodel}
\begin{tabular}{@{}lrr@{}}
\toprule
رویکرد & تاخیر (\lr{ms, p95}) & تعداد کوئری‌های \lr{DB} \\ \midrule
\lr{ArangoDB} & \lr{245} & \lr{1} \\
\lr{MongoDB + Neo4j} & \lr{412} & \lr{4} \\ \bottomrule
\end{tabular}
\end{table}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.9]
        \begin{scope}
            \pgfmathsetmacro{\barw}{0.4}

            \draw[->] (0,0) -- (4,0) node[anchor=west] {\scriptsize رویکرد};
            \draw[->] (0,0) -- (0,3.5) node[anchor=south] {\scriptsize تاخیر (\lr{ms, p95})};

            \foreach \x/\name in {0.8/ArangoDB,2.6/Polyglot} {
                \node[anchor=mid, rotate=45] at (\x,-0.1) {\scriptsize \name};
            }

            \foreach \y/\label in {0/0,1/100,2/200,3/400} {
                \draw (0,\y) -- (-0.05,\y);
                \node[left] at (-0.05,\y) {\scriptsize \label};
            }

            % scale /100
            \def\Amm{245/100}
            \def\Pmm{412/100}

            \fill[blue!60] (0.8-\barw/2,0) rectangle ++(\barw,\Amm);
            \fill[orange!70] (2.6-\barw/2,0) rectangle ++(\barw,\Pmm);

            \draw[blue!60] (2.8,3.0) rectangle ++(0.2,0.15);
            \node[anchor=west] at (3.0,3.075) {\scriptsize ArangoDB};
            \draw[orange!70] (2.8,2.7) rectangle ++(0.2,0.15);
            \node[anchor=west] at (3.0,2.775) {\scriptsize Polyglot};
        \end{scope}
    \end{tikzpicture}
    \caption{تاخیر تحلیل نفوذ اجتماعی چندمدلی: \lr{ArangoDB} در مقابل رویکرد چندزبانه.}
    \label{fig:mm-influence}
\end{figure}

\textbf{بحث مقایسه‌ای:}
\begin{itemize}
    \item \lr{ArangoDB} تحلیل نفوذ اجتماعی را در حدود \lr{۲۴۵} میلی‌ثانیه (\lr{p95}) به عنوان یک پرس‌وجوی واحد تکمیل می‌کند، در حالی که راهکار چندزبانه به حدود \lr{۴۱۲} میلی‌ثانیه نیاز دارد که منجر به \lr{۴۰-۴۱\%} کاهش تاخیر می‌شود.
    \item پایپ‌لاین چندزبانه معمولاً شامل موارد زیر است:
    \begin{enumerate}
        \item یک یا دو پرس‌وجوی گراف برای شناسایی اینفلوئنسرها و محاسبه معیارهای مرکزیت پایه.
        \item یک یا دو پرس‌وجوی سند برای واکشی و تجمیع داده‌های تعامل پست.
        \item هماهنگی سمت برنامه برای ادغام، فیلتر کردن و مرتب‌سازی نتایج.
    \end{enumerate}
    \item با \lr{ArangoDB}، کل جریان کاری سمت سرور اجرا می‌شود؛ بهینه‌ساز می‌تواند فیلترها و پروژکشن‌ها را به داده‌ها نزدیک‌تر کند و نتایج میانی هرگز پایگاه‌داده را ترک نمی‌کنند که به طور قابل توجهی حرکت داده‌ها و سربار سریال‌سازی را کاهش می‌دهد.
    \item آزمایش‌های \lr{MM1} و \lr{MM2} با هم نشان می‌دهند که طراحی چندمدلی \lr{ArangoDB} نه تنها معماری برنامه را ساده می‌کند بلکه می‌تواند مزایای عملکردی قابل توجهی برای پرس‌وجوهای تحلیلی واقعی و بین‌مدلی به همراه داشته باشد.
\end{itemize}

\subsection{تحلیل مقیاس‌پذیری}

\subsubsection{مقیاس‌پذیری افقی}

توان عملیاتی در برابر اندازه خوشه (بار کاری \lr{YCSB A}) در جدول \ref{tab:scaling} نشان داده شده است.

\begin{table}[h]
\centering
\caption{مقیاس‌پذیری خوشه (هزار عملیات در ثانیه)}
\label{tab:scaling}
\begin{tabular}{@{}lrrr@{}}
\toprule
گره‌ها & \lr{ArangoDB} & \lr{MongoDB} & \lr{Cassandra} \\ \midrule
\lr{۱} & \lr{28.4} & \lr{30.2} & \lr{32.1} \\
\lr{۳} & \lr{76.2} & \lr{82.5} & \lr{89.4} \\
\lr{۵} & \lr{118.3} & \lr{128.7} & \lr{142.8} \\
\lr{۷} & \lr{152.1} & \lr{168.4} & \lr{188.2} \\ \bottomrule
\end{tabular}
\end{table}

\textbf{کارایی مقیاس‌پذیری (\lr{۵} گره):}
\begin{itemize}
    \item \lr{ArangoDB}: \lr{83.1\%} (\lr{۴.۱۷} برابر افزایش سرعت).
    \item \lr{MongoDB}: \lr{85.2\%} (\lr{۴.۲۶} برابر افزایش سرعت).
    \item \lr{Cassandra}: \lr{89.0\%} (\lr{۴.۴۵} برابر افزایش سرعت).
\end{itemize}

همه سیستم‌ها به دلیل سربار هماهنگی مقیاس‌پذیری زیرخطی نشان می‌دهند. معماری بدون ارباب \lr{Cassandra} بهترین کارایی مقیاس‌پذیری را فراهم می‌کند، در حالی که \lr{ArangoDB} و \lr{MongoDB} همچنان مقیاس‌پذیری نزدیک به خطی قوی در محدوده تست شده به دست می‌آورند.

\subsubsection{گراف‌های هوشمند}

شاردینگ گراف هوشمند \lr{ArangoDB} عملکرد پرس‌وجوی گراف توزیع شده را به طور قابل توجهی بهبود می‌بخشد:

\begin{table}[h]
\centering
\caption{گراف هوشمند در مقابل شاردینگ استاندارد (خوشه \lr{۳} گره‌ای، میلی‌ثانیه)}
\label{tab:smartgraph}
\begin{tabular}{@{}lrr@{}}
\toprule
پرس‌وجو & استاندارد & گراف هوشمند \\ \midrule
پیمایش \lr{۲} گام & \lr{18.5} & \lr{9.2} \\
پیمایش \lr{۳} گام & \lr{52.3} & \lr{26.7} \\
تطبیق الگو & \lr{215.4} & \lr{128.3} \\ \bottomrule
\end{tabular}
\end{table}

گراف‌های هوشمند با هم‌مکان کردن داده‌های گراف مرتبط و به حداقل رساندن ارتباطات شبکه در طول پیمایش‌ها، تاخیر را تقریباً \lr{۴۸-۵۰\%} کاهش می‌دهند. این ویژگی به ویژه هنگام استقرار \lr{ArangoDB} به عنوان یک موتور گراف توزیع شده مهم است.

\subsection{بهره‌وری منابع}

\subsubsection{کارایی حافظه}

استفاده از حافظه برای \lr{۱۰} میلیون سند (\lr{۱۰} گیگابایت اندازه منطقی):

\begin{table}[h]
\centering
\caption{ردپای حافظه (گیگابایت)}
\label{tab:memory}
\begin{tabular}{@{}lrr@{}}
\toprule
پایگاه‌داده & مجموعه کاری & کل \\ \midrule
\lr{ArangoDB} & \lr{8.2} & \lr{12.4} \\
\lr{MongoDB} & \lr{7.8} & \lr{11.6} \\
\lr{Neo4j} & \lr{9.5} & \lr{15.2} \\
\lr{Redis} & \lr{14.3} & \lr{14.3 (in-mem)} \\
\lr{Cassandra} & \lr{6.8} & \lr{10.2} \\ \bottomrule
\end{tabular}
\end{table}

سربار حافظه \lr{ArangoDB} با \lr{MongoDB} قابل مقایسه است و به دلیل ساختارهای پشتیبانی چندمدلی و متادیتای ایندکس اضافی، کمی بالاتر از \lr{Cassandra} است. \lr{Neo4j} حافظه بیشتری برای ساختارهای گراف مصرف می‌کند، در حالی که \lr{Redis} تمام داده‌ها را طبق طراحی در حافظه ذخیره می‌کند.

\subsubsection{استفاده از \lr{CPU}}

کارایی \lr{CPU} (عملیات در ثانیه بر هسته، \lr{YCSB-A}):

\begin{itemize}
    \item \lr{MongoDB}: \lr{۱،۲۶۰ ops/core}.
    \item \lr{ArangoDB}: \lr{۱،۱۸۵ ops/core} (\lr{۹۴\%} از \lr{MongoDB}).
    \item \lr{Cassandra}: \lr{۱،۳۴۰ ops/core}.
\end{itemize}

کارایی \lr{CPU} در \lr{ArangoDB} رقابتی است، با سربار کمی بالاتر که احتمالاً ناشی از تجزیه \lr{AQL} و پشتیبانی چندمدلی است، اما برای اکثر بارهای کاری گلوگاه نخواهد بود.

\subsection{خلاصه یافته‌های عملکرد}

\begin{enumerate}
    \item \textbf{عملیات سند:} \lr{ArangoDB} به \lr{۸۵-۹۵\%} از توان عملیاتی پایگاه‌داده‌های تخصصی برای بارهای کاری سند دست می‌یابد، با برخی پرس‌وجوهای پیچیده که عملکرد بهتری نسبت به گزینه‌های تخصصی دارند.
    \item \textbf{پیمایش‌های گراف:} رقابتی با \lr{Neo4j} برای پرس‌وجوهای کم‌عمق، و \lr{۱۵-۲۴\%} سریع‌تر برای پیمایش‌های عمیق‌تر (\lr{۳+} گام) در مجموعه داده و پیکربندی تست شده.
    \item \textbf{دسترسی کلید-مقدار:} کندتر از \lr{Redis} در حافظه اما قابل مقایسه با \lr{Cassandra} با پشتیبانی دیسک؛ مناسب زمانی که پرس‌وجوی غنی‌تری مورد نیاز است.
    \item \textbf{پرس‌وجوهای چندمدلی:} \lr{۳۰-۴۰\%} سریع‌تر از رویکردهای چندزبانه به دلیل حذف سربار هماهنگی و بهینه‌سازی یکپارچه.
    \item \textbf{مقیاس‌پذیری:} مقیاس‌پذیری افقی خوب (حدود \lr{۸۳\%} کارایی در \lr{۵} گره)، با گراف‌های هوشمند که عملکرد گراف توزیع شده را به طور چشمگیری بهبود می‌بخشند.
    \item \textbf{استفاده از منابع:} کارایی حافظه و \lr{CPU} قابل مقایسه با پایگاه‌داده‌های تخصصی، که نشان‌دهنده سربار ناچیز از پشتیبانی چندمدلی است.
\end{enumerate}

\section{موارد استفاده و کاربردهای عملی}

\subsection{سناریوهای به نفع \lr{ArangoDB}}

\subsubsection{برنامه‌های چندوجهی}

برنامه‌هایی که به چندین مدل داده نیاز دارند بیشترین بهره را از \lr{ArangoDB} می‌برند:

\begin{itemize}
    \item \textbf{شبکه‌های اجتماعی:} پروفایل‌های کاربر (اسناد) + دوستی‌ها (گراف‌ها) + داده‌های نشست (کلید-مقدار).
    \item \textbf{پلتفرم‌های تجارت الکترونیک:} کاتالوگ محصولات (اسناد) + گراف‌های توصیه + سبدهای خرید (کلید-مقدار).
    \item \textbf{گراف‌های دانش:} موجودیت‌ها و روابط با متادیتای غنی.
    \item \textbf{کشف تقلب:} اسناد تراکنش که از طریق شبکه‌های ارتباطی به هم متصل شده‌اند.
    \item \textbf{مدیریت محتوا:} محتوای سلسله‌مراتبی (گراف‌ها) با متادیتا (اسناد).
\end{itemize}

\subsubsection{پرس‌وجوهای تحلیلی پیچیده}

زمانی که پرس‌وجو‌ها به طور مکرر پیمایش‌ها، الحاق‌ها و تجمیع‌ها را ترکیب می‌کنند، زبان پرس‌وجوی یکپارچه \lr{ArangoDB} مزایای قابل توجهی نسبت به سازماندهی چندین پایگاه‌داده ارائه می‌دهد.

\textbf{مثال:} تحلیل ارزش طول عمر مشتری که نیاز دارد به:
\begin{enumerate}
    \item پیمایش گراف: شبکه‌های ارجاع مشتری.
    \item الحاق اسناد: تاریخچه خرید با جزئیات محصول.
    \item تجمیع‌ها: کل درآمد به ازای هر بخش مشتری.
\end{enumerate}

\subsection{سناریوهای به نفع پایگاه‌داده‌های تخصصی}

\subsubsection{بارهای کاری ساده کلید-مقدار}

برای برنامه‌هایی که تحت سلطه عملیات ساده \lr{GET/SET} با حداقل پرس‌وجو هستند، معماری در حافظه \lr{Redis} عملکرد برتری را ارائه می‌دهد. مثال‌ها:
\begin{itemize}
    \item ذخیره‌سازی نشست.
    \item لایه‌های کش.
    \item لیدربوردهای بی‌درنگ.
\end{itemize}

\subsubsection{توان عملیاتی نوشتن عظیم}

\lr{Cassandra} برای بارهای کاری سنگین-نوشتن که نیاز به مقیاس‌پذیری شدید دارند عالی است:
\begin{itemize}
    \item داده‌های سری زمانی (سنسورهای \lr{IoT}).
    \item ثبت رخداد (\lr{Event logging}) در مقیاس بزرگ.
    \item پایپ‌لاین‌های تحلیلی سنگین-الحاق.
\end{itemize}

\subsubsection{تحلیل گراف عمیق}

برای برنامه‌هایی که به طور انحصاری الگوریتم‌های پیچیده گراف (\lr{PageRank}، تشخیص جامعه و غیره) را اجرا می‌کنند، کتابخانه الگوریتم‌های تخصصی \lr{Neo4j} و ذخیره‌سازی گراف بومی ممکن است مزایایی را ارائه دهند، به ویژه برای گراف‌های بسیار بزرگ (بیش از \lr{۵۰} میلیون راس).

\subsection{ملاحظات مهاجرت}

سازمان‌هایی که مهاجرت به \lr{ArangoDB} را در نظر دارند باید موارد زیر را ارزیابی کنند:

\begin{table}[h]
\centering
\caption{عوامل تصمیم‌گیری مهاجرت}
\label{tab:migration}
\small
\begin{tabular}{@{}p{5cm}p{8cm}@{}}
\toprule
عامل & مزیت \lr{ArangoDB} \\ \midrule
پیچیدگی عملیاتی & کاهش یافته (پایگاه‌داده واحد) \\
سرعت توسعه & سریع‌تر (\lr{API} یکپارچه) \\
هزینه زیرساخت & کمتر (سیستم‌های کمتر) \\
سازگاری داده & آسان‌تر (مدل تراکنش واحد) \\
انعطاف‌پذیری پرس‌وجو & بالاتر (\lr{AQL} چندمدلی) \\
حداکثر عملکرد & ممکن است برای بارهای کاری تخصصی کمتر باشد \\
بلوغ اکوسیستم & کمتر بالغ نسبت به \lr{MongoDB/Neo4j} \\ \bottomrule
\end{tabular}
\end{table}

\section{بحث و تحلیل موازنه}

\subsection{موازنه چندمدلی}

بنچمارک‌های ما نشان می‌دهند که رویکرد چندمدلی \lr{ArangoDB} شامل موازنه‌های عملکردی است:

\textbf{هزینه‌ها:}
\begin{itemize}
    \item \lr{۵-۱۵\%} کاهش توان عملیاتی برای عملیات ساده سند در مقایسه با \lr{MongoDB}.
    \item \lr{۱۵-۲۰\%} پیمایش‌های گراف کم‌عمق کندتر در مقایسه با \lr{Neo4j}.
    \item عملیات کلید-مقدار به طور قابل توجهی کندتر در مقایسه با \lr{Redis} در حافظه.
\end{itemize}

\textbf{مزایا:}
\begin{itemize}
    \item \lr{۳۰-۴۰\%} پرس‌وجوهای چندمدلی سریع‌تر در مقایسه با معماری‌های چندزبانه.
    \item عملکرد رقابتی یا برتر برای عملیات پیچیده.
    \item سادگی عملیاتی و کاهش سربار زیرساخت.
\end{itemize}

این موازنه زمانی مطلوب می‌شود که:
\begin{equation}
P_{\text{multi}} \cdot F_{\text{multi}} > \sum_{i} P_{i} \cdot F_{i} + C_{\text{coord}}
\end{equation}

که در آن:
\begin{itemize}
    \item $P_{\text{multi}}$ = عملکرد سیستم چندمدلی.
    \item $F_{\text{multi}}$ = کسری از پرس‌وجوهای چندمدلی.
    \item $P_{i}$ = عملکرد پایگاه‌داده تخصصی $i$.
    \item $F_{i}$ = کسری از پرس‌وجوهایی که از مدل $i$ استفاده می‌کنند.
    \item $C_{\text{coord}}$ = سربار هماهنگی (شبکه، سریال‌سازی، مدیریت).
\end{itemize}

\subsection{وقتی تخصص برنده می‌شود}

پایگاه‌داده‌های تخصصی در سناریوهای خاص مزایای خود را حفظ می‌کنند:

\subsubsection{همگنی بار کاری}

اگر بیش از \lr{۹۵\%} پرس‌وجوها از یک مدل داده واحد استفاده کنند، مزایای عملکردی پایگاه‌داده‌های تخصصی بر مزایای چندمدلی می‌چربد. بهبود \lr{۵-۱۵\%} توان عملیاتی ممکن است تاثیر قابل توجهی بر هزینه‌های زیرساخت در مقیاس بزرگ داشته باشد.

\subsubsection{مقیاس شدید}

در مقیاس‌های شدید (پتابایت، میلیاردها موجودیت)، بهینه‌سازی‌های پایگاه‌داده‌های تخصصی حیاتی‌تر می‌شوند:
\begin{itemize}
    \item بهینه‌سازی مسیر نوشتن \lr{Cassandra} برای توان عملیاتی نوشتن انبوه حیاتی است.
    \item ذخیره‌سازی گراف بومی \lr{Neo4j} برای گراف‌های با بیش از \lr{۱۰۰} میلیون راس ضروری است.
    \item طراحی تک‌رشته‌ای \lr{Redis} برای تاخیرهای میکروثانیه بهینه است.
\end{itemize}

\subsubsection{الگوریتم‌های تخصصی}

پایگاه‌داده‌هایی با کتابخانه‌های الگوریتم گسترده (مانند کتابخانه علوم داده گراف \lr{Neo4j}) قابلیت‌هایی را ارائه می‌دهند که به راحتی در سیستم‌های عمومی قابل تکرار نیستند.

\subsection{پیامدهای زبان پرس‌وجو}

نحو یکپارچه \lr{AQL} هم مزایا و هم محدودیت‌هایی دارد:

\textbf{مزایا:}
\begin{itemize}
    \item زبان واحد بار شناختی توسعه‌دهندگان را کاهش می‌دهد.
    \item بهینه‌ساز می‌تواند به طور سراسری در مرزهای مدل بهینه‌سازی کند.
    \item یادگیری آسان‌تر در مقایسه با مدیریت چندین زبان پرس‌وجو.
\end{itemize}

\textbf{محدودیت‌ها:}
\begin{itemize}
    \item ممکن است فاقد برخی ویژگی‌های تخصصی زبان‌های دامنه خاص (مانند نحو تطبیق الگوی \lr{Cypher}) باشد.
    \item تنظیم عملکرد نیاز به درک نکات بهینه‌سازی خاص \lr{AQL} و برنامه‌های اجرا دارد.
    \item اکوسیستم و ابزارهای شخص ثالث کمتر از سیستم‌های با سابقه طولانی‌تر مانند \lr{MongoDB} و \lr{Neo4j} گسترده هستند.
\end{itemize}

\subsection{پیامدهای معماری}

انتخاب \lr{ArangoDB} در مقابل ماندگاری چندزبانه بر معماری سیستم تاثیر می‌گذارد:

\subsubsection{ماندگاری چندزبانه (\lr{Polyglot Persistence})}
\begin{itemize}
    \item \textbf{مزیت:} حداکثر عملکرد برای هر نوع بار کاری با استفاده از سیستم‌های تخصصی.
    \item \textbf{مزیت:} فناوری‌های بالغ و آزمون‌داده با اکوسیستم‌های بزرگ.
    \item \textbf{عیب:} استقرار و عملیات پیچیده در چندین نوع پایگاه‌داده.
    \item \textbf{عیب:} چالش‌های همگام‌سازی و تکرار داده‌ها.
    \item \textbf{عیب:} عدم وجود تراکنش‌های بین پایگاه‌داده‌ای بومی.
    \item \textbf{عیب:} هزینه‌های زیرساخت و نگهداری بالاتر.
\end{itemize}

\subsubsection{چندمدلی (\lr{ArangoDB})}
\begin{itemize}
    \item \textbf{مزیت:} عملیات ساده شده (مدیریت یک موتور واحد).
    \item \textbf{مزیت:} تراکنش‌های یکپارچه در سراسر مدل‌ها.
    \item \textbf{مزیت:} پرس‌وجوهای چندمدلی سریع‌تر و کاهش حرکت داده‌ها.
    \item \textbf{عیب:} جریمه عملکردی اندک برای بارهای کاری بسیار تخصصی.
    \item \textbf{عیب:} اکوسیستم کمتر بالغ در مقایسه با سیستم‌های تک‌مدلی غالب.
    \item \textbf{عیب:} پتانسیل قفل شدن فروشنده یا فناوری برای موارد استفاده چندمدلی.
\end{itemize}

\subsection{روندهای آینده}

چندین روند ممکن است بر بحث چندمدلی در مقابل پایگاه‌داده تخصصی تاثیر بگذارد:

\subsubsection{تکامل سخت‌افزار}
\begin{itemize}
    \item \textbf{حافظه پایدار:} تمایز بین پایگاه‌داده‌های در حافظه و دیسک‌محور را محو می‌کند و پتانسیل کاهش مزیت \lr{Redis} را دارد.
    \item \textbf{ذخیره‌سازی محاسباتی:} گلوگاه‌های حرکت داده را کاهش می‌دهد که ممکن است به نفع سیستم‌های چندمدلی باشد که منطق بیشتری را نزدیک به ذخیره‌سازی پردازش می‌کنند.
    \item \textbf{سرعت‌های شبکه:} بهبود بیشتر در پهنای باند و تاخیر شبکه می‌تواند برخی از هزینه‌های هماهنگی چندزبانه را کاهش دهد اما پیچیدگی بین‌سیستمی را از بین نخواهد برد.
\end{itemize}

\subsubsection{پیشرفت‌های پردازش پرس‌وجو}
\begin{itemize}
    \item \textbf{بهینه‌سازی مبتنی بر \lr{ML}:} ممکن است به ویژه به نفع سیستم‌های چندمدلی باشد که برنامه‌های پرس‌وجوی پیچیده بین‌مدلی را یاد می‌گیرند.
    \item \textbf{اجرای تطبیقی:} تنظیم برنامه پرس‌وجو در زمان اجرا می‌تواند بارهای کاری ناهمگن را بیشتر بهینه کند.
    \item \textbf{پرس‌وجوهای کامپایل شده:} کاهش سربار تفسیر برای پرس‌وجوهای پیچیده \lr{AQL} می‌تواند شکاف‌ها را با موتورهای تخصصی کاهش دهد.
\end{itemize}

\subsubsection{معماری‌های \lr{Cloud-Native}}

معماری‌های بدون سرور و ذخیره‌سازی تفکیک شده ممکن است به نفع رویکردهای چندمدلی باشند با سرشکن کردن سربار پشتیبانی چندمدلی در بین بسیاری از مستاجران و ساده‌سازی مدیریت عملیاتی.

\section{نتیجه‌گیری}

\subsection{خلاصه یافته‌ها}

این مطالعه جامع عملکرد \lr{ArangoDB} را به عنوان یک پایگاه‌داده چندمدلی در برابر سیستم‌های پیشرو \lr{NoSQL} تخصصی ارزیابی کرد. یافته‌های کلیدی ما:

\begin{enumerate}
    \item \textbf{عملکرد تخصصی رقابتی:} \lr{ArangoDB} به \lr{۸۵-۹۵\%} از توان عملیاتی پایگاه‌داده‌های تخصصی برای بارهای کاری سند و گراف دست می‌یابد، با برخی پرس‌وجوهای پیچیده که عملکرد بهتری نسبت به گزینه‌های تخصصی دارند.
    
    \item \textbf{مزیت چندمدلی:} پرس‌وجوهایی که چندین مدل داده را ترکیب می‌کنند، \lr{۳۰-۴۰\%} سریع‌تر در \lr{ArangoDB} نسبت به پیاده‌سازی‌های چندزبانه معادل اجرا می‌شوند، که ناشی از حذف سربار هماهنگی و بهینه‌سازی یکپارچه است.
    
    \item \textbf{مقیاس‌پذیری:} \lr{ArangoDB} مقیاس‌پذیری افقی خوبی نشان می‌دهد (حدود \lr{۸۳\%} کارایی در \lr{۵} گره)، با گراف‌های هوشمند که عملکرد پرس‌وجوی گراف توزیع شده را به طور قابل توجهی بهبود می‌بخشند.
    
    \item \textbf{کارایی منابع:} استفاده از حافظه و \lr{CPU} قابل مقایسه با پایگاه‌داده‌های تخصصی است که نشان‌دهنده سربار ناچیز از پشتیبانی چندمدلی است.
    
    \item \textbf{موازنه‌ها:} موازنه‌های عملکردی برای بارهای کاری ساده و همگن وجود دارد، اما قابلیت‌های پرس‌وجوی یکپارچه و سادگی عملیاتی مزایای جبران‌کننده‌ای برای برنامه‌های ناهمگن فراهم می‌کنند.
\end{enumerate}

\subsection{توصیه‌های عملی}

بر اساس تحلیل ما، توصیه می‌کنیم:

\textbf{\lr{ArangoDB} را انتخاب کنید اگر:}
\begin{itemize}
    \item برنامه‌ها به دو یا چند مدل داده (اسناد، گراف‌ها، کلید-مقدار) نیاز دارند.
    \item پرس‌وجو‌ها به طور مکرر مرزهای مدل را طی می‌کنند.
    \item سادگی عملیاتی و کاهش پیچیدگی زیرساخت اولویت دارند.
    \item سرعت توسعه و ابزارسازی یکپارچه مهم است.
    \item مقیاس هدف کوچک تا متوسط است (تا صدها میلیون موجودیت).
\end{itemize}

\textbf{پایگاه‌داده‌های تخصصی را انتخاب کنید اگر:}
\begin{itemize}
    \item بیش از \lr{۹۵\%} بار کاری از یک مدل داده واحد استفاده می‌کند.
    \item نیازمندی‌های مقیاس شدید (پتابایت، میلیاردها موجودیت).
    \item حداکثر عملکرد و حداقل تاخیر حیاتی هستند.
    \item الگوریتم‌های تخصصی و ابزارسازی اکوسیستم ضروری هستند.
    \item سازمان در حال حاضر تخصص عمیقی در یک فناوری تخصصی داده شده دارد.
\end{itemize}

\subsection{مشارکت‌های پژوهشی}

این مطالعه موارد زیر را ارائه می‌دهد:
\begin{itemize}
    \item ارزیابی عملکرد جامع و مستقل \lr{ArangoDB} در برابر چندین پایگاه‌داده تخصصی در بارهای کاری سند، گراف و کلید-مقدار.
    \item کمی‌سازی مزایای عملکرد پرس‌وجوی چندمدلی و تاثیر شاردینگ گراف هوشمند.
    \item تحلیل ساختاریافته از موازنه‌های عملکرد ذاتی در معماری‌های چندمدلی.
    \item راهنمایی عملی برای انتخاب فناوری پایگاه‌داده بر اساس ویژگی‌های بار کاری و سازمانی.
\end{itemize}

\subsection{محدودیت‌ها و کارهای آینده}

مطالعه ما محدودیت‌هایی دارد که جهت‌هایی را برای تحقیقات آینده پیشنهاد می‌کند:

\subsubsection{تنوع بار کاری}

در حالی که ما بارهای کاری متنوعی را تست کردیم، سناریوهای اضافی شایسته بررسی هستند:
\begin{itemize}
    \item ورودی داده‌های جریانی/بی‌درنگ.
    \item بارهای کاری پرس‌وجوی مکانی.
    \item برنامه‌های متمرکز بر جستجوی تمام‌متن.
    \item الگوهای داده‌های سری زمانی و نمونه‌برداری کاهشی.
\end{itemize}

\subsubsection{تست در مقیاس بزرگتر}

بزرگترین تست‌های ما از گراف‌هایی با \lr{۵۰} میلیون راس استفاده کردند. ارزیابی در مقیاس‌های بزرگتر (میلیاردها موجودیت) نشان خواهد داد که آیا ویژگی‌های عملکرد به طور بنیادی تغییر می‌کنند و آیا گراف‌های هوشمند \lr{ArangoDB} مزایای خود را حفظ می‌کنند.

\subsubsection{محیط‌های ابری}

تمام تست‌ها از سخت‌افزار اختصاصی استفاده کردند. الگوهای استقرار ابری (کانتینری‌سازی، بدون سرور، سرویس‌های مدیریت شده) ممکن است پروفایل‌های عملکرد متفاوتی نشان دهند، به ویژه تحت بارهای کاری انفجاری یا چندمستاجری.

\subsubsection{مدل‌های سازگاری}

ما بر تنظیمات سازگاری پیش‌فرض تمرکز کردیم. تحلیل دقیق موازنه‌های سازگاری-عملکرد در تنظیمات مختلف (مثلاً دوام قوی‌تر در \lr{RocksDB}، فاکتورهای تکرار متفاوت) بینش‌های اضافی ارائه خواهد داد.

\subsubsection{ویژگی‌های پیشرفته}

کارهای آینده باید موارد زیر را ارزیابی کنند:
\begin{itemize}
    \item عملکرد جستجوی تمام‌متن در برابر \lr{Elasticsearch}.
    \item عملکرد پرس‌وجوی مکانی در برابر \lr{PostGIS}.
    \item بهینه‌سازی سری زمانی در برابر \lr{InfluxDB} و \lr{TimescaleDB}.
    \item قابلیت‌های پردازش جریان و تغییر داده (\lr{CDC}).
\end{itemize}

\subsection{سخن پایانی}

پارادایم پایگاه‌داده چندمدلی، که با نمونه \lr{ArangoDB} نشان داده شده است، یک مصالحه عملی بین عملکرد تخصصی و سادگی عملیاتی را نشان می‌دهد. نتایج ما نشان می‌دهد که این مصالحه اغلب مطلوب است: جریمه عملکرد برای بارهای کاری تخصصی متوسط است (\lr{۵-۱۵\%})، در حالی که مزایا برای سناریوهای چندمدلی قابل توجه است (\lr{۳۰-۴۰\%} بهبود).

با پیچیده‌تر شدن برنامه‌ها و عادی شدن ناهمگنی داده‌ها، پایگاه‌داده‌های چندمدلی جایگزینی جذاب برای معماری‌های ماندگاری چندزبانه ارائه می‌دهند. بلوغ سیستم‌هایی مانند \lr{ArangoDB} نشان می‌دهد که «یک سایز مناسب همه» ممکن است بهینه نباشد، اما «یک سایز مناسب بسیاری» به طور فزاینده‌ای قابل دوام است.

چشم‌انداز پایگاه‌داده همچنان در حال تکامل است، با مرزهای محو شده بین دسته‌ها و ظهور رویکردهای ترکیبی. تحقیقات آینده باید این تحولات را ردیابی کرده، معماری‌های جدید را ارزیابی و با پیشرفت فناوری، خطوط مبنای عملکرد را به‌روزرسانی کنند.

\section*{تقدیر و تشکر}

 از منابع محاسباتی فراهم شده برای اجرای بنچمارک قدردانی می‌کنم و همچنین از جوامع متن‌باز که سیستم‌های پایگاه‌داده تست شده را نگهداری می‌کنند.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}